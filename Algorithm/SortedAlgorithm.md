#排序算法
***
>排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，外部排序由于排序的数据量很大，内存一次不能容纳全部排序记录，在排序过程中需要访问外存。

>排序算法

>>内部排序算法（内存排序）

>>       插入排序:  直接插入排序, 希尔排序
>>       选择排序:  简单选择排序,堆排序
>>       交换排序:  冒泡排序,快速排序
>>       归并排序                                              
>>       基数排序                        
>>                                 
>>外部排序（内存和外存结合使用）

>当n较大，则采用时间复杂度为O(nlogn)的排序算法：快速排序、堆排序或归并排序
>快速排序：目前最好的基于比较的内部排序算法中最好的排序算法，当待排序的关键字是随机分布时，快速排序的平均时间最短。

>***

>###1.插入排序算法-直接插入排序（Straight Insertion Sort）
>>将一个记录插入到已排序的有序表中，从而得到有序记录新增1的有序表。即：先将序列的第一个记录看作有序子序列，然后从第二条记录逐个进行插入，直至整个序列有序位置。
>>要点：设立哨兵，作为临时存储和判断数组边界用。
>>核心代码:
>>>
<pre><code>
void straightInsertionSort(int a[], int n) {
	int i, j;
	for (i = 1; i < n; i++) {
		j = i;
		int cur = a[i];
		while (cur < a[j-1]) {
			a[j] = a[j - 1];
			j--;
		}
		a[j] = cur;
		print(a, 8, i);
	}
}
</code></pre>

>>二分插入排序，2-路插入排序

>###2.插入排序——希尔排序（Shell‘s Sort)
>>缩小增量排序
>>将整个待排序序列分割成若干个子序列分别进行直接插入排序，待整个序列中记录基本有序时，再对全体记录进行直接插入排序

>>算法描述
>>     1.选择一个增量序列，t1,t2,...,tj,...,ti,...tk,其中ti>tj,tk=1;
>>     2.按照增量序列个数k，对序列进行k趟排序
>>     3.每趟排序，对应的增量为ti,将待排序序列分成若干长度为m的子序列，分别对各个子序列进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表的长度为整个序列的长度。

>>算法实现示例：
>>设置增量序列为:d = {n/2,4/n,8/n,.....,1} n为要排序序列的长度
>>将序列按照增量d分成若干组子序列，然后每组中记录的下标差d。对每组中全部元素进行直接插入排序后，再设置一个较小的增量d,对序列进行分组，将每个分组再进行插入排序。继续不断缩小增量直至增量d=1,使用直接插入排序

>>代码示例
>>
<pre><code>
void shellSort(int a[], int n) {
	int i, j;
	int d = n/2;
	//int loop = (int)log(n);
	while(d>=1){ //循环次数
		for (i = d; i < n; i++) { // 以d为增量进行直接插入排序
			int cur = a[i];
			j = i;
			while (j - d >= 0 && cur < a[j - d]) {
				a[j] = a[j - d];
				j -= d;
			}
			a[j] = cur;
			print(a, n, i);
		}
		d /= 2;
	}
}
</code></pre>

>###选择排序-简单选择排序（Simple Selection Sort）
>>在要排序的序列中，选择最小（或最大）的一个元素与第一个位置上的元素进行交换，然后选择剩余元素中最小（或最大）的元素与第二个位置上的元素进行交换，以
此类推，直至最后一个元素被选出……

>>算法步骤：
>>第一趟，从n个记录中找出关键码最小（或最大）的与第一个记录进行交换；
>>第二趟，从剩余的n-1个关键码中选出最小（或最大）的与第二个记录进行交换；
>>第i(i<n)趟，从剩余的n-i个记录中选出关键码最小（或最大的）与第i个进行交换

>>代码示例：
>>
<pre><code>
void selectionSort(int a[] , int n) {
		int i, j;
		for (i = 0; i < n-1; i++) {
			int k = i;
			int cur = a[i];
			for (j = i + 1; j < n; j++) {
				if (a[k] > a[j]) {
					k = j;
				}
			}
			if (i != k) {
				a[i] = a[k];
				a[k] = cur;
			}
			print(a, n, i);
		}
	}
</code></pre>

>###简单选择排序的改进——二元选择排序
>>简单选择排序，每趟循环只能对一个元素进行定位。采用二元选择排序，每次循环都可以对两个元素进行定位（当前趟的最大元素和最小元素），从而减少循环的趟数。改进后对n个数据进行排序，最多只需要进行n/2趟循环即可。

>>代码示例
>>
<pre><code>
void binarySelectionSort(int a[], int n) {
		int i, j, min, max;
		for (i = 0; i <n / 2; i++) {
			min = i; max = i; //记录最大和最小值的位置
			for (j = i + 1; j < n-i; j++) {
				if (a[max] < a[j]) {
					max = j;
				}
				if (a[min] > a[j]) {
					min = j;
				}
			}
			int cur = a[min]; a[min] = a[i]; a[i] = cur;
			//注意这里的处理，当min,max关于中轴对称时，是不能执行第二个交换的
			if ((max+min+1)!=n) {
				cur = a[max]; a[max] = a[n - i - 1]; a[n - i - 1] = cur;
				//printf("%d %d\n", i,n -i-1);
			}
			print(a, n, i);
		}
	}
</code></pre>

>###选择排序——堆排序
>>堆排序实际上是一种树形排序，是对直接选择排序的改进。

>>时常利用大顶堆或小顶堆作为存储结构进行排序。堆实际上是一棵完全二叉树（所谓完全二叉树是指一棵深度为k，且有2^k-1个节点的树称为满二叉树，深度为k，有n个节点的二叉树，当且仅当每一个节点都与深度为k的满二叉树，序号从1至n的节点对应时，称之为完全二叉树）。用数组存储完全二叉树，初始时把要排序的n个数的序列看作是一个顺序存储的二叉树（一维数组存储二叉树），调整他们的存储顺序，是使之成为一个堆，将堆顶元素输出，得到n个元素中最大（或最小）的元素，此时调整堆中余下的n-1个元素，使之成为堆，输出堆顶元素，再调整，依此类推，直至所有的n个元素全部输出，这个过程称之为堆排序。

>>实现堆排序需要解决的核心问题：

>>1.初始时的建堆

>>2.输出堆顶元素以后，剩余元素的调整，恢复堆

>>首先第二个问题的解决其实仍旧可以沿用第一个问题的解决方式。

>>下面给出小顶堆的调整过程：
>>     1)设有n个元素的堆，输出堆顶后，剩下m-1个元素。将堆底元素送入堆顶（最后一个元素与堆顶元素进行交换），维持堆的结构性后，堆的偏序性被破坏，破坏该性质的点仅仅是堆顶元素；
>>      2)将根节点与左子树、右子树根节点元素较小的交换；
>>      3)如果与左子树交换，则左子树的偏序性，可能被破环，对左子树重复步骤2）
>>      4)如果与右子树交换，则右子树的偏序性，可能被破环，对右子树重复步骤2）
>>   重复上述步骤2），3），4）直至堆的结构性，偏序性都得到维持


>>第一个问题的解决方案：

>>算法的相关实现：

>>从以上算法的描述看出，堆排序需要两个过程，建堆，调整堆。所以，分成两部分：建堆函数，调整渗透函数

>>代码示例

>><pre><code>
/*选择排序算法之堆排序算法 begin*/
	void heapSort(int a[], int n) {
		int i;
		//print(a, n, 0);
		heapBuild(a, n);
		//printf("是吗？\n");
		print(a, n, 0);
		for (i = 0; i < n; i++) {
			swap(&a[0], &a[n - 1 - i]);
			heapAdjust(a, n - 1 - i, 0);
			print(a, n, i);
		}
	}
	void swap(int *a, int *b) {
		int temp = *a;
		*a = *b;
		*b = temp;
	}
	/*
	    已知a[cur,n]出元素a[cur]外均满足大顶堆性质，调整使a[cur]满足
		参数列表：
		   a : 元素数组
		   n : 数组长度
		   cur:  待调整元素位置
	*/
	void heapAdjust(int a[], int n, int cur) {
		int c = a[cur];
		//求当前节点的左孩子
		int child = 2 * cur + 1;
		while (child < n) {
			if (child + 1 < n && a[child] < a[child + 1]) {
				child++;
			}
			if (c < a[child]) {
				a[cur] = a[child];
				cur = child;
				child = child * 2 + 1;
			}
			else {
				break;
			}
		}	
		a[cur] = c;
	}
	/*
	     已知原序列a,和序列长度n，建立大顶堆
		   a : 元素数组
		   n : 数组长度
	*/
	void heapBuild(int a[], int n) {
		int loop = n; //记录循环次数
		while (--loop >= 0) {
			heapAdjust(a, n, loop);
		//	print(a, n, loop);
		}
	}
	/*选择排序算法之堆排序算法 end*/
</code></pre>

>>算法分析：设有n个节点，那么n = 2^k - 1，树高为。从根高叶子节点的比较至多2*(k-1)次，交换次数最多为k次。所以在存储结构——堆，建好以后，排序过程中筛选次数不超过下列计算公式；
**2(log(n-1)+log(n-2)+...+log 1) <2*n*log n ; ** 而建堆的比比较次数比超过4n次，因此堆排序的时间复杂度，最坏情况下为O(nlogn)

>###交换排序——冒泡排序（Bubble Sort）
>>算法思想：冒泡排序关注的是一组元素中相邻两个元素的顺序，其关键是保证这一组元素任何相邻的两个元素都不是逆序的，就是保证该组元素逆序数为零。通过对当前未排序元素相邻元素自上而下进行比较和调整，将较大的元素下沉，较小的元素上冒。即，每当比较两个相邻元素，发现他们是逆序的，就交换他们的位置。

>>算法步骤：
>>***
>>      对于一组可比较元素  a[0,n)
>>      for  i<-0 to n-2
>>         for j = 0 to n-1-i
>>            if(a[j]>a[j+1])  swap(a[j],a[j+1]);
>>***
    
>>代码示例
    
>>
<pre><code>
//交换排序之冒泡排序
void bubbleSort(int a[], int n) {
	int i, j;
        for (i = 0; i < n - 2; i++) {
		for (j = 0; j < n - 1 - i; j++) {
			if (a[j] > a[j + 1]) {
				swap(&a[j], &a[j+1]);
			}
		}
		print(a, n, i);
	}
}
</code></pre>
 
>>###冒泡排序改进
>>设置标志性变量，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没有进行数据交换，说明数据已经按照要求排序，可以立即解说排序。

>>1.设置标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置后的记录均已交换到位，故在先一趟排序时，只需要扫描pos位置即可。   

>>代码示例


>>
<pre><code>
 //冒泡排序算法改进
void bubbleSortImprovement_1(int a[], int n) {
	int i = n - 1;
	int j;
	while (i > 0) {
		int pos = 0;
		for (j = 0; j < i; j++) {
			if (a[j] > a[j + 1]) {
				pos = j;
				swap(&a[j], &a[j + 1]);
			}
		}
		print(a, n, i);
		i = pos;//下一次检测位置
	}
}
</code></pre>

>>2.在每趟排序中进行两次正想和反向冒泡，分别得到最大和最小值，这样可以将排序趟数减少近一半。
    
>>*** 
               
>###交换排序—快速排序(Quick Sort)
>>算法思想：对于一个序列，选取基准的关键码，通过一轮比较，将该关键码放到其排序后的最终位置，最终达到的结果是关键码左侧的值均小于该关键码，关键码右侧的均大于关键码。然后对关键码左右两侧的子序列重复同样的操作，直至序列有序

>>算法的递归实现

>>算法的核心；是通过比较找出关键码的位置，同时使其左侧元素均小于关键码，右侧元素均大于关键码
 
>>代码示例

>>
<pre><code>
 /*交换排序之快速排序 begin*/
void quickSort(int a[],int low,  int height) {
	if (low < height) {
		int povit = partition(a, low, height);
		quickSort(a, povit + 1, height);
		quickSort(a, low, povit - 1);
	}
}
int partition(int a[], int l, int r) {
	int povit = a[l];
	while (l < r) {
		while (l < r && povit <= a[r]) {
			r--;
		}
		if (l < r) {
			a[l++] = a[r];	
		}
		while (l < r && povit >= a[l]) {
			l++;
		}
		if (l < r) {
			a[r--] = a[l];
		}
	}
	//注意代码的时候在这里出了错误
	a[l] = povit;
	print(a, 8, l);
	return l;
}
/*交换排序之快速排序 begin*/
</code></pre>
    
>>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法.
>>***
  
>###归并排序（Merge Sort)
>> 算法思想：将两个或者是两个以上的有序表合并成一个新的有序表，也就是说把待排序序列分为若干个子序列，每个子序列都是有序的，然后将子序列进行合并。

>>1个元素的表总是有序的。所以对n 个元素的待排序列，每个元素可看成1 个有序子表。对子表两两合并生成n/2个子表，所得子表除最后一个子表长度可能为1 外，其余子表长度均为2。再进行两两合并，直到生成n 个元素按关键码有序的表。

>>迭代算法代码示例
>>
<pre><code>
void mergeSortInteration(int arr[], int len) {
		int* a = arr;
		int* b = (int*)malloc(len * sizeof(int*));
		int seg, start;
		for (seg = 1; seg < len; seg += seg) {
			for (start = 0; start < len; start += seg + seg) {
				int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);
				int k = low;
				int start1 = low, end1 = mid;
				int start2 = mid, end2 = high;
				while (start1 < end1 && start2 < end2)
					b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];
				while (start1 < end1)
					b[k++] = a[start1++];
				while (start2 < end2)
					b[k++] = a[start2++];
			}
			int* temp = a;
			a = b;
			b = temp;
		}
		if (a != arr) {
			int i;
			for (i = 0; i < len; i++)
				b[i] = a[i];
			b = a;
		}
		free(b);
	}
</code></pre>
>>***
>>二路归并递归算法代码示例
>>
<pre><code>void mergeSortRecursive(int arr[], int reg[], int start, int end) {
		if (start >= end)
			return;
		int len = end - start, mid = (len >> 1) + start;
		int start1 = start, end1 = mid;
		int start2 = mid + 1, end2 = end;
		mergeSortRecursive(arr, reg, start1, end1);
		mergeSortRecursive(arr, reg, start2, end2);
		int k = start;
		while (start1 <= end1 && start2 <= end2)
			reg[k++] = arr[start1] < arr[start2] ? arr[start1++] : arr[start2++];
		while (start1 <= end1)
			reg[k++] = arr[start1++];
		while (start2 <= end2)
			reg[k++] = arr[start2++];
		for (k = start; k <= end; k++)
			arr[k] = reg[k];
}
</code></pre>
    
>####桶排序/基数排序(Radix Sort)
>>####桶排序
>>>基本思想：是将阵列分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。
    
>>>简单来说，就是把数据分组，放在一个个的桶中，然后对每个桶里面的在进行排序。
例如要对大小为[1..1000]范围内的n个整数A[1..n]排序。

>>>>首先，可以把桶设为大小为10的范围，具体而言，设集合B[1]存储[1..10]的整数，集合B[2]存储   (10..20]的整数，……集合B[i]存储(   (i-1)*10,   i*10]的整数，i   =   1,2,..100。总共有  100个桶。

>>>>然后，对A[1..n]从头到尾扫描一遍，把每个A[i]放入对应的桶B[j]中。  再对这100个桶中每个桶里的数字排序，这时可用冒泡，选择，乃至快排，一般来说任  何排序法都可以。

>>>>最后，依次输出每个桶里面的数字，且每个桶中的数字从小到大输出，这  样就得到所有数字排好序的一个序列了。

>>>假设有n个数字，有m个桶，如果数字是平均分布的，则每个桶里面平均有n/m个数字。如果对每个桶中的数字采用快速排序，那么整个算法的复杂度是 **O(n   +   m   *   n/m*log(n/m))   =   O(n   +   nlogn   –   nlogm)**.从上式看出，当m接近n的时候，桶排序复杂度接近O(n)。

>>>当然，以上复杂度的计算是基于输入的n个数字是平均分布这个假设的。这个假设是很强的  ，实际应用中效果并没有这么好。如果所有的数字都落在同一个桶中，那就退化成一般的排序了。

>>>冒泡，插入，选择等几大排序算法 ，大部分时间复杂度都是O（n2），也有部分排序算法时间复杂度是O(nlogn)。而桶式排序却能实现O（n）的时间复杂度。但桶排序的缺点是：

>>>>1）首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，一个就是所谓的桶，比如待排序值是从0到m-1，那就需要m个桶，这个桶数组就要至少m个空间。

>>>> 2）其次待排序的元素都要在一定的范围内等等。

>>>桶式排序是一种分配排序。分配排序的特定是不需要进行关键码的比较，但前提是要知道待排序列的一些具体情况。分配排序的基本思想：说白了就是进行多次的桶式排序。
基数排序过程无须比较关键字，而是通过“分配”和“收集”过程来实现排序。它们的时间复杂度可达到线性阶：O(n)。

>>>>实例:

>>>>扑克牌中52 张牌，可按花色和面值分成两个字段，其大小关系为：

>>>>花色：梅花< 方块< 红心< 黑心

>>>>面值：2 < 3 < 4 < 5 < 6 < 7 < 8 < 9 < 10 < J < Q < K < A

>>>>即两张牌，若花色不同，不论面值怎样，花色低的那张牌小于花色高的，只有在同花色情况下，大小关系才由面值的大小确定。这就是多关键码排序。

>>>>为得到排序结果，我们讨论两种排序方法。

>>>>方法1：先对花色排序，将其分为4 个组，即梅花组、方块组、红心组、黑心组。再对每个组分别按面值进行排序，最后，将4 个组连接起来即可。

>>>>方法2：先按13 个面值给出13 个编号组(2 号，3 号，…，A 号)，将牌按面值依次放入对应的编号组，分成13 堆。再按花色给出4 个编号组(梅花、方块、红心、黑心)，将2号组中牌取出分别放入对应花色组，再将3 号组中牌取出分别放入对应花色组，……，这样，4 个花色组中均按面值有序，然后，将4 个花色组依次连接起来即可。

>>>>设n 个元素的待排序列包含d 个关键码{k1，k2，…，kd}，则称序列对关键码{k1，k2，…，kd}有序是指：对于序列中任两个记录r[i]和r[j](1≤i≤j≤n)都满足下列有序关系：

>>>>** ![公式](<img src="http://chart.googleapis.com/chart?cht=tx&chl=(k_i%5E1%2Ck_i%5E2%2C...%2Ck_i%5Ed)%3C(k_j%5E1%2Ck_j%5E2%2C...%2Ck_j%5Ed)" style="border:none;" />) **

>>>>其中k1 称为最主位关键码，kd 称为最次位关键码  。

>>>>两种多关键码排序方法：

>>>>多关键码排序按照从最主位关键码到最次位关键码或从最次位到最主位关键码的顺序逐次排序，分两种方法：

>>>>最高位优先(Most Significant Digit first)法，简称MSD 法：

>>>>>1）先按k1 排序分组，将序列分成若干子序列，同一组序列的记录中，关键码k1 相等。

>>>>>2）再对各组按k2 排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码kd 对各子组排序后。

>>>>>3）再将各组连接起来，便得到一个有序序列。扑克牌按花色、面值排序中介绍的方法一即是MSD 法。

>>>>最低位优先(Least Significant Digit first)法，简称LSD 法：

>>>>>1) 先从kd 开始排序，再对kd-1进行排序，依次重复，直到按k1排序分组分成最小的子序列后。

>>>>>2) 最后将各个子序列连接起来，便可得到一个有序的序列, 扑克牌按花色、面值排序中介绍的方法二即是LSD 法。

>>>>基于LSD方法的链式基数排序的基本思想

>>>>>“多关键字排序”的思想实现“单关键字排序”。对数字型或字符型的单关键字，可以看作由多个数位或多个字符构成的多关键字，此时可以采用“分配-收集”的方法进行排序，这一过程称作基数排序法，其中每个数字或字符可能的取值个数称为基数。比如，扑克牌的花色基数为4，面值基数为13。在整理扑克牌时，既可以先按花色整理，也可以先按面值整理。按花色整理时，先按红、黑、方、花的顺序分成4摞（分配），再按此顺序再叠放在一起（收集），然后按面值的顺序分成13摞（分配），再按此顺序叠放在一起（收集），如此进行二次分配和收集即可将扑克牌排列有序。

>>####基数排序
>>>是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。

>>>代码示例

>>>