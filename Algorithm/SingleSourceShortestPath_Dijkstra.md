#单源最短路径（有向图）
***
>个人理解：__只有有向图才能称为最短路径，而无向图我们采用最小生成树来描述__这个观点留待以后验证
>在最短路径问题中，给定一个带权重有向图G=(V,E)和权重函数w:E->**R**,该权重函数将每条边映射到实数值的权重上。
>>*这里注释：以上的理解是有偏差的，无向图同样可以有最短路径，重要的是途中的边是有权重的。Dijkstra算法要要求途中不存在负权重的边**
图中一条路径
>
<img src="http://chart.googleapis.com/chart?cht=tx&chl=p%20%3D%20%3Cv_0%2Cv_1%2Cv_2%2C...%2Cv_k%3E" style="border:none;" />

>的**权重**w(p)是构成该路径的所有边的权重之和：<img src="http://chart.googleapis.com/chart?cht=tx&chl=w(p)%20%3D%20%5Csum_%7Bi%3D1%7D%5E%20w%20w(v_%7Bi-1%7D%2Cv_i)" style="border:none;" />
>定义从节点u到节点v的**最短权重路径 

><img src="http://chart.googleapis.com/chart?cht=tx&chl=%5Cdelta%20(u%2Cv)" style="border:none;" /> 

>如下：

><img src="http://chart.googleapis.com/chart?cht=tx&chl=%5Cdelta%20(u%2Cv)%20%3D%20%5Cbegin%7Bcases%7D%20min%20%5C%7B%20w(p)%3Au-%3Ev%5C%7D%20%5Cmbox%7B%20if%20a%20path%20from%20%7Du%5Cmbox%7B%20to%20%7Dv%20%5C%5C%20%5Cinfty%20%20%5Cmbox%7B%20thoerwise%7D%5C%5C%20%5Cend%7Bcases%7D%0A" style="border:none;" />

>从结点u到节点v的**最短路径**定义为任何一条权重为 <img src="http://chart.googleapis.com/chart?cht=tx&chl=w(p)%20%3D%20%5Cdelta%20(u%2Cv)" style="border:none;" /> 的从u到v的路径p.
>***

>##Dijkstra算法
>>该算法解决的带有权重的有向图上的单源最短路径问题，其要求所有边的权重都为非负值。
>>算法思想：维护两个结点集合S和V-S。从源点s到集合S中所有结点的最短路径都已经找到。算法重复的从集合V-S中选择距离s路径最短的结点u加入到集合S中，然后对从u出发的到V-S集合中的结点进行松弛。所谓松弛指的是求出与u相连的所有节点到源点s目前为止的最短路径。此时，S中任何节点与V-S集合中任何节点都是不直接相连的，这一点很重要。

>>###具体解释Dijkstra算法：
>>给定二维邻接矩阵E，表示点与边之间的关系:

>>     e   1    2    3    4    5    6 

>>     1   0    1   12   -1   -1   -1

>>     2  -1   -1    9    3   -1   -1

>>     3  -1   -1    0    -1   5   -1

>>     4  -1   -1    4     0  13   15

>>     5  -1   -1   -1    -1   0    4

>>     6  -1   -1   -1    -1  -1    0 

>>其中-1表示两点之间没有路径。
>>为了完成算法，我们还需要一个数组dist来存储1号源点好其余各个定点的初始距离，其中-1表示距离为无穷

>>             1  2   3    4   5   6
>>     dist    0  1   12  -1  -1  -1

>>将此时dist数组中的值称之为“估计值”
>>求1号源点到其余各个顶点的最短路程：
>>1.首先求得距离1号定点距离最近的结点，通过dist数组可知当前距离1最近的结点是2号结点。就此选择2号结点并入S集合，此时dist数组中的2号位置的数值就是1号源点到2号结点的最短距离。其原因就就是图中的每条边都是正值，因此不可能通过第三个点进行中转。
>>2.此时从2号点出发到达剩余点的边有 2->3 ，因此只能讨论3号定点。我们要看的是通过2->3这条边能否将1号结点到3号结点的距离变短。其中dist[2]+e[2][3]表示1号结点经过边2->3到达3号结点的距离，其中dist[2]表示1号结点到2号结点的最短距离，e[2][3]表示边2->3的距离，其含义就是从一号结点先到二号结点，在经过2->3這条边到达三号结点的路径长度。比较从一号结点直接到三号结点的路径程度和从一号结点经过二号结点再到三号节点路径长度的大小，即 dst[3] = 12  > dst[2]+e[2][3]  =10 ,所以此时将dist[3]更新为10.这个过程的专业术语叫做“松弛”。
>>同理，通过2->4(e[2][4]).可以将dist[4]的值从正无穷松弛为4；
>>此时二号结点所有出边都已经进行了松弛，松弛完毕后的数组如下：

>>             1   2   3   4  5  6   
>>     dist    0   1  10   4 -1 -1
>>然后，从剩余V-S集合中选择距离一号结点最近的结点，也就是从 3  4  5  6 中选取， 通过比较dist数组中各个位置上的值，选择4号结点， 此时dist[4]，就变成了真实值。寻找四号结点的出边（除去与S集合中相连的结点），4->5,4-6;  以此可以尝试松弛dist[5],[6] ... 重复该过程直至E-S集合为空。
>>得到最后的结果：

>>             1   2   3   4  5  6   
>>     dist    0   1  10   4 13 17

>***

>思想：每次找到距离源点最近的一个点，然后以该顶点为中心进行扩散，最终得到到其余所有点的最短路径。
>***
>基本步骤；
>1.将顶点集合E划分为两个集合已知最短路径结点集合S， 未知最短路径结点集合E-S=Q 。初始状态为P集合中只有源点一个结点。同时，用flag[]数组标识结点是否已经在集合P中，当flag[i]=1,表示i节点已经在P集合中，flag[i]=0则表示在Q集合中。设置dist[s] = 0,表示源点到本身的距离为0.如果存在源点能够直达的结点 dist[i] = e[s][i]; 所有源点不能直达的结点dist[i] = -1;
>2.从Q集合中选择距离源点s最近的结点i(即dist[i]最小),将i加入到集合S中，同时，考察以i为起点的边，对每一条边做松弛操作。
>重复第二步，直至集合Q为空。最终dist数组中的值就是源点s到各个结点的最短路径。

>***
>示例代码：

><pre><code>
void dijkstra() {
	int e[10][10], dist[10], flag[10];
	int i, j,E,V;
	printf("请输入定点数目和边数目");
	scanf_s("%d %d", &V, &E);
	/*
	*初始化工作
	*/
	for (i = 1; i <= V; i++) {
		for (j = 0; j <= V; j++) {
			if (i == j) {
				e[i][j] = 0;
			}
			else {
				e[i][j] = INF;
			}
		}
	}
	int u, v, t;
	//读入边集，u为起始点，v为终点，t为边的权重
	for (i = 1; i <= E;i++) {
		scanf_s("%d %d %d", &u, &v, &t);
		e[u][v] = t;
	}
	//初始化操作
	for (i = 1; i <= V; i++) {
		dist[i] = e[1][i];
		flag[i] = 0;
	}
	flag[1] = 1;
	//算法的核心步骤
	//由于有V个定点，所以最多做V次选择，选出当前距离源点最近的点
	for (i = 1; i < V; i++) {
		//从Q集合中找到距离源点最近的节点
		int min = INF;
		for (j = 2; j <= V; j++) {
			if (!flag[j] && min > dist[j]) {
				min = dist[j];
				u = j;
			}
		}
		flag[u] = 1;
		for (v = 1; v <= E; v++) {
			 //必要的操作步骤，否则会产生越界影响
			if (e[u][v] < INF) {
				if (dist[u] + e[u][v] < dist[v]) {
					dist[v] = dist[u] + e[u][v];
				}
			}
		}
	}
	for (i = 1; i <= V; i++) {
		printf("%d ", dist[i]);
	}
}
</code></pre>
>***



